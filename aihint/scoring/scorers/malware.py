"""
Malware and Phishing Checker

Checks URLs against malware and phishing databases for security scoring.
"""

import aiohttp
import asyncio
import hashlib
import logging
import re
from datetime import datetime, timezone
from typing import Dict, Any, Tuple, List
from urllib.parse import urlparse


class MalwareChecker:
    """Checks URLs against malware and phishing databases."""
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        self.logger = logging.getLogger(__name__)
        self.timeout = self.config.get('timeout', 10)
        
        # API configurations
        self.apis = {
            'google_safe_browsing': {
                'enabled': self.config.get('google_safe_browsing', {}).get('enabled', False),
                'api_key': self.config.get('google_safe_browsing', {}).get('api_key'),
                'url': 'https://safebrowsing.googleapis.com/v4/threatMatches:find'
            },
            'virustotal': {
                'enabled': self.config.get('virustotal', {}).get('enabled', False),
                'api_key': self.config.get('virustotal', {}).get('api_key'),
                'url': 'https://www.virustotal.com/vtapi/v2/url/report'
            },
            'phishtank': {
                'enabled': self.config.get('phishtank', {}).get('enabled', False),
                'api_key': self.config.get('phishtank', {}).get('api_key'),
                'url': 'https://checkurl.phishtank.com/checkurl/'
            }
        }
    
    async def score(self, url: str) -> Tuple[float, Dict[str, Any]]:
        """
        Score URL for malware and phishing threats.
        
        Returns:
            Tuple of (score, detailed_metrics)
        """
        try:
            # Run all malware checks in parallel
            check_tasks = []
            
            if self.apis['google_safe_browsing']['enabled']:
                check_tasks.append(self._check_google_safe_browsing(url))
            
            if self.apis['virustotal']['enabled']:
                check_tasks.append(self._check_virustotal(url))
            
            if self.apis['phishtank']['enabled']:
                check_tasks.append(self._check_phishtank(url))
            
            # Always run basic checks
            check_tasks.extend([
                self._check_suspicious_patterns(url),
                self._check_shortened_urls(url),
                self._check_suspicious_domains(url)
            ])
            
            # Execute all checks
            results = await asyncio.gather(*check_tasks, return_exceptions=True)
            
            # Process results
            check_results = []
            total_score = 0.0
            max_score = 0.0
            threats_found = []
            
            for result in results:
                if isinstance(result, Exception):
                    self.logger.warning(f"Malware check failed: {result}")
                    continue
                
                check_results.append(result)
                total_score += result['score']
                max_score += 1.0
                
                if result['threats']:
                    threats_found.extend(result['threats'])
            
            # Calculate final score
            if threats_found:
                final_score = 0.0  # Any threat = 0 score
            else:
                final_score = total_score / max_score if max_score > 0 else 1.0
            
            return final_score, {
                'malware_score': final_score,
                'threats_found': threats_found,
                'checks_performed': len(check_results),
                'check_details': check_results,
                'success': True,
                'timestamp': datetime.now(timezone.utc).isoformat()
            }
            
        except Exception as e:
            self.logger.error(f"Malware checking failed for {url}: {e}")
            return 0.0, {
                'malware_score': 0.0,
                'error': str(e),
                'success': False,
                'timestamp': datetime.now(timezone.utc).isoformat()
            }
    
    async def _check_google_safe_browsing(self, url: str) -> Dict[str, Any]:
        """Check URL against Google Safe Browsing API."""
        try:
            if not self.apis['google_safe_browsing']['api_key']:
                return {
                    'check': 'google_safe_browsing',
                    'score': 1.0,
                    'threats': [],
                    'message': 'Google Safe Browsing not configured'
                }
            
            api_key = self.apis['google_safe_browsing']['api_key']
            api_url = self.apis['google_safe_browsing']['url']
            
            payload = {
                'client': {
                    'clientId': 'aihint-scorer',
                    'clientVersion': '1.0.0'
                },
                'threatInfo': {
                    'threatTypes': ['MALWARE', 'SOCIAL_ENGINEERING', 'UNWANTED_SOFTWARE'],
                    'platformTypes': ['ANY_PLATFORM'],
                    'threatEntryTypes': ['URL'],
                    'threatEntries': [{'url': url}]
                }
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    f"{api_url}?key={api_key}",
                    json=payload,
                    timeout=aiohttp.ClientTimeout(total=self.timeout)
                ) as response:
                    data = await response.json()
                    
                    if 'matches' in data and data['matches']:
                        threats = [match['threatType'] for match in data['matches']]
                        return {
                            'check': 'google_safe_browsing',
                            'score': 0.0,
                            'threats': threats,
                            'message': f'Threats detected: {", ".join(threats)}'
                        }
                    else:
                        return {
                            'check': 'google_safe_browsing',
                            'score': 1.0,
                            'threats': [],
                            'message': 'No threats detected by Google Safe Browsing'
                        }
                        
        except Exception as e:
            return {
                'check': 'google_safe_browsing',
                'score': 0.5,
                'threats': [],
                'error': str(e),
                'message': 'Google Safe Browsing check failed'
            }
    
    async def _check_virustotal(self, url: str) -> Dict[str, Any]:
        """Check URL against VirusTotal API."""
        try:
            if not self.apis['virustotal']['api_key']:
                return {
                    'check': 'virustotal',
                    'score': 1.0,
                    'threats': [],
                    'message': 'VirusTotal not configured'
                }
            
            api_key = self.apis['virustotal']['api_key']
            api_url = self.apis['virustotal']['url']
            
            # Hash the URL for VirusTotal
            url_hash = hashlib.sha256(url.encode()).hexdigest()
            
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    f"{api_url}?apikey={api_key}&resource={url_hash}",
                    timeout=aiohttp.ClientTimeout(total=self.timeout)
                ) as response:
                    data = await response.json()
                    
                    if data.get('response_code') == 1:
                        positives = data.get('positives', 0)
                        total = data.get('total', 1)
                        detection_rate = positives / total
                        
                        if detection_rate > 0.1:  # More than 10% detection
                            return {
                                'check': 'virustotal',
                                'score': 0.0,
                                'threats': [f'Detected by {positives}/{total} engines'],
                                'message': f'Malware detected by {positives} engines'
                            }
                        else:
                            return {
                                'check': 'virustotal',
                                'score': 1.0,
                                'threats': [],
                                'message': f'Clean: {positives}/{total} detections'
                            }
                    else:
                        return {
                            'check': 'virustotal',
                            'score': 0.8,
                            'threats': [],
                            'message': 'URL not in VirusTotal database'
                        }
                        
        except Exception as e:
            return {
                'check': 'virustotal',
                'score': 0.5,
                'threats': [],
                'error': str(e),
                'message': 'VirusTotal check failed'
            }
    
    async def _check_phishtank(self, url: str) -> Dict[str, Any]:
        """Check URL against PhishTank database."""
        try:
            if not self.apis['phishtank']['enabled']:
                return {
                    'check': 'phishtank',
                    'score': 1.0,
                    'threats': [],
                    'message': 'PhishTank not enabled'
                }
            
            api_url = self.apis['phishtank']['url']
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    api_url,
                    data={'url': url, 'format': 'json'},
                    timeout=aiohttp.ClientTimeout(total=self.timeout)
                ) as response:
                    data = await response.json()
                    
                    if data.get('in_database') and data.get('verified'):
                        return {
                            'check': 'phishtank',
                            'score': 0.0,
                            'threats': ['Phishing site detected'],
                            'message': 'URL confirmed as phishing site'
                        }
                    else:
                        return {
                            'check': 'phishtank',
                            'score': 1.0,
                            'threats': [],
                            'message': 'URL not flagged as phishing'
                        }
                        
        except Exception as e:
            return {
                'check': 'phishtank',
                'score': 0.5,
                'threats': [],
                'error': str(e),
                'message': 'PhishTank check failed'
            }
    
    async def _check_suspicious_patterns(self, url: str) -> Dict[str, Any]:
        """Check for suspicious URL patterns."""
        threats = []
        score = 1.0
        
        # Check for suspicious patterns
        suspicious_patterns = [
            r'[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}',  # IP address
            r'bit\.ly|tinyurl\.com|goo\.gl|t\.co',  # URL shorteners
            r'[a-zA-Z0-9]{20,}',  # Very long random strings
            r'[^a-zA-Z0-9.-]',  # Special characters
        ]
        
        import re
        for pattern in suspicious_patterns:
            if re.search(pattern, url, re.IGNORECASE):
                threats.append(f'Suspicious pattern: {pattern}')
                score -= 0.2
        
        # Check for typosquatting patterns
        common_typos = ['gogle', 'facebok', 'twiter', 'youtub', 'amazom']
        domain = urlparse(url).netloc.lower()
        for typo in common_typos:
            if typo in domain:
                threats.append(f'Possible typosquatting: {typo}')
                score -= 0.3
        
        return {
            'check': 'suspicious_patterns',
            'score': max(0.0, score),
            'threats': threats,
            'message': f'Pattern analysis: {len(threats)} suspicious patterns found'
        }
    
    async def _check_shortened_urls(self, url: str) -> Dict[str, Any]:
        """Check if URL is a shortened URL (potential risk)."""
        shorteners = [
            'bit.ly', 'tinyurl.com', 'goo.gl', 't.co', 'ow.ly', 'is.gd',
            'short.link', 'tiny.cc', 'shorturl.at', 'cutt.ly'
        ]
        
        domain = urlparse(url).netloc.lower()
        is_shortened = any(shortener in domain for shortener in shorteners)
        
        if is_shortened:
            return {
                'check': 'shortened_urls',
                'score': 0.3,
                'threats': ['Shortened URL detected'],
                'message': 'URL is shortened - potential security risk'
            }
        else:
            return {
                'check': 'shortened_urls',
                'score': 1.0,
                'threats': [],
                'message': 'URL is not shortened'
            }
    
    async def _check_suspicious_domains(self, url: str) -> Dict[str, Any]:
        """Check for suspicious domain characteristics."""
        domain = urlparse(url).netloc.lower()
        threats = []
        score = 1.0
        
        # Check domain length (very long domains are suspicious)
        if len(domain) > 50:
            threats.append('Very long domain name')
            score -= 0.2
        
        # Check for excessive subdomains
        subdomain_count = domain.count('.')
        if subdomain_count > 3:
            threats.append('Excessive subdomains')
            score -= 0.2
        
        # Check for mixed case (potential homograph attacks)
        if domain != domain.lower() and domain != domain.upper():
            threats.append('Mixed case domain (potential homograph attack)')
            score -= 0.3
        
        # Check for numbers in domain (less trustworthy)
        if re.search(r'\d', domain):
            threats.append('Numbers in domain name')
            score -= 0.1
        
        return {
            'check': 'suspicious_domains',
            'score': max(0.0, score),
            'threats': threats,
            'message': f'Domain analysis: {len(threats)} suspicious characteristics'
        }
